<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Document</title>
  </head>
  <body></body>
  <script>
    /* const m = new Map();
    // alert(m.has("firstName")); // false
    // alert(m.get("firstName")); // undefined
    // alert(m.size); // 0

    m.set("firstName", "Matt").set("lastName", "Frisbie");
    // alert(m.has("firstName")); // true
    // alert(m.get("firstName")); // Matt
    // alert(m.size); // 2

    m.delete("firstName"); // 只删除这一个键/值对
    // alert(m.has("firstName")); // false
    // alert(m.has("lastName")); // true
    // alert(m.size); // 1

    m.clear(); // 清除这个映射实例中的所有键/值对
    alert(m.has("firstName")); // false
    alert(m.has("lastName")); // false
    alert(m.size); // 0 */

    /* // set()方法返回映射实例，因此可以把多个操作连缀起来，包括初始化声明：
    const m = new Map().set("key1", "val1");
    m.set("key2", "val2").set("key3", "val3");
    alert(m.size); // 3 */

    /* const m = new Map();
    const functionKey = function () {};
    const symbolKey = Symbol();
    const objectKey = new Object();

    m.set(functionKey, "functionValue");
    m.set(symbolKey, "symbolValue");
    m.set(objectKey, "objectValue");
    console.log(m.get(functionKey));
    console.log(m.get(symbolKey));
    console.log(m.get(objectKey));

    // SameValueZero 比较意味着独立实例不冲突
    alert(m.get(function () {})); // undefined */

    /* const m = new Map();
    const objKey = {},
      objVal = {},
      arrKey = [],
      arrVal = [];
    m.set(objKey, objVal);
    m.set(arrKey, arrVal);
    objKey.foo = "foo";
    objVal.bar = "bar";
    arrKey.push("foo");
    arrVal.push("bar");
    console.log(objKey); // {foo: "foo"}
    console.log(m.get(objKey)); // {bar: "bar"}
    console.log(arrKey); // ["foo"]
    console.log(m.get(arrKey)); // ["bar"] */

    /* const m = new Map();
    const a = 0 / "", // NaN
      b = 0 / "", // NaN
      pz = +0,
      nz = -0;
    console.log(a === b); // false
    console.log(pz === nz); // true
    m.set(a, "foo");
    m.set(pz, "bar");
    console.log(m.get(b)); // foo
    console.log(m.get(nz)); // bar */

    /* //-----------Map映射实例可提供一个迭代器
     const m = new Map([
      ["key1", "val1"],
      ["key2", "val2"],
      ["key3", "val3"],
    ]);
    console.log(m.entries === m[Symbol.iterator]); //true
    console.log(m.entries());

    for (let pair of m.entries()) {
      console.log(pair);
    }
    // [key1,val1]
    // [key2,val2]
    // [key3,val3]
    for (let pair of m[Symbol.iterator]()) {
      console.log(pair);
    }
    // [key1,val1]
    // [key2,val2]
    // [key3,val3] */

    /* 
    //---------不使用迭代器，而是使用回调方式，则可以调用映射的 forEach(callback, opt_thisArg)
//---------方法并传入回调
    const m = new Map([
      ["key1", "val1"],
      ["key2", "val2"],
      ["key3", "val3"],
    ]);
    m.forEach((val, key) => console.log(`${key} -> ${val}`));
    // key1 -> val1
    // key2 -> val2
    // key3 -> val3 */

    /* //-----keys()和 values()分别返回以插入顺序生成键和值的迭代器
    const m = new Map([
      ["key1", "val1"],
      ["key2", "val2"],
      ["key3", "val3"],
    ]);
    for (let key of m.keys()) {
      console.log(key);
    }
    // key1
    // key2
    // key3
    for (let key of m.values()) {
      console.log(key);
    }
    // value1
    // value2
    // value3 */

    /* //----------健和值在迭代器遍历时可修改，映射内部的引用不能
    //----------但是并不妨碍修改作为键或值的对象内部的属性，因为这样并不影响它们在映射实例中的身份
    const m1 = new Map([["key1", "val1"]]);
    //作为键的字符串原始值不能修改
    for (let key of m1.keys()) {
      key = "newKey";
      console.log(key); // newKey
      console.log(m1.get("key1")); // val1
    }
    console.log(m1.keys());

    const keyObj = { id: 1 };
    const m = new Map([[keyObj, "val1"]]);
    //修改了作为键的对象的属性，但对象在映射内部仍然引用相同的值
    for (let key of m.keys()) {
      console.log(key); // {id: 1}
      key.id = "newKey";
      console.log(key); // {id: "newKey"}
      console.log(m.get(keyObj)); // val1
    }
    console.log(keyObj); // {id: "newKey"} */

    
  </script>
</html>
